# Auto detect text files and perform LF normalization
* text=auto

这是一个学习笔记，所有关于学习的记录都会在这里。
2018.11.28 粗略学习了c标准库，这本书太难，不适合现在的我，准备学基础的c++
购买了c++ primer第五版，90元，开始学习
第一天学习学个屁，20181129
const是一个限定符，被它修饰的变量的值不能改变。对于一般的变量来说，其实没有顶层const和底层const的区别，而只有向指针这类复合类型的基本变量，才有这样的区别。
C++有类模板，也有函数模板，vector是一个类模板，模板不是类，但是编译器根据模板创建类。需要指定一些信息，来使模板来实例化为类，形式为模板名字+尖括号+尖括号内信息。
迭代器用来访问string内的元素或者vector的元素，vector和string都支持下标运算符，也都支持迭代器。
const_iterator和常量指针差不多，能读取而不能修改它所指的元素值，iterator可读可写。
*解引用 .成员访问  it→mem 等价于 (*it).mem，已知的限制是不能在for循环内向迭代器添加元素，也不能进行改变对象容量的操作，否则会使其失效。
数组和vector的区别在于，数组没有名字，通过位置来访问，而且大小一定，不能随意改变，在一些程序里面性能较好，但是也损失了一些灵活性。
使用for循环下标来访问数组。
这傻逼东西老子有点醉 好几把男
double型数据不能用于精确比较，int用于精确比较
函数重载只比较参数个数和参数类型 若相同 则为相同函数
在函数调试时确定具体的问题 然后单步调试或者进步函数内部调试
每次测试之后都要对函数模块进行充分调试
8位构成一个字节  int=4字节 char=1字节 
数组名本身就是数组的地址
strcpy需要string.h的头文件
	// 用一个符号表示是否被选中
		char * mark = "■";
		if (!po->selected)
			mark = "□";

		// 显示这一选项
		printf(" %s %s \n", mark, po->answer);
		#pragma warning( disable : 4996)
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int main()
{
	const char* filename = "d:/aaa.txt";
	FILE* fp = fopen(filename, "wb");
	if (fp == NULL)
	{
		printf("wrong");
		return -1;
	}
	double a = 3 / 4.0;
	fwrite(&a, 1, sizeof(a), fp);
	system("pause");
	return 0;
}


#include<stdio.h>
#include<stdlib.h>
#include <iostream>
#include <fstream>
struct Student
{
	char gender; // 性别
	int id; // id
	char name[16]; // 年龄
};
int main()
{
	const char* filename = "d:/aaa.txt";
	FILE* fp = fopen(filename, "wb");
	if (fp == NULL)
	{
		printf("wrong");
		return -1;
	}
	Student someone = { 20150101, 'M', "Noname" };
	fwrite(&someone.gender, 1, 4, fp);
	fwrite(&someone.id, 1, 1, fp);
	fwrite(&someone.name, 1, 16, fp);

	fclose(fp);
	system("pause");
	return 0;
}

 error : Element <SubSystem> has an invalid value of "CONSOLE(/SUBSYSTEM:CONSOLE)".

  fatal error LNK1120: 1 个无法解析的外部命令
  #include<stdio.h>
#define PI 3.14  
int main()
{
	double r = 1.2;
	double area = PI * r * r;
	system("pause");
	return 0;
}
